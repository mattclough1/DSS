{"version":3,"sources":["webpack:///webpack/bootstrap 0e2daa0ff6297c50c7a5","webpack:///./src/util/trim.js","webpack:///./src/util/index.js","webpack:///./src/util/singleLineComment.js","webpack:///./src/dss.js","webpack:///./src/util/cleanLine.js","webpack:///./src/util/endMultiLineComment.js","webpack:///./src/util/getStrIndex.js","webpack:///./src/util/normalize.js","webpack:///./src/util/parseMultiLine.js","webpack:///./src/util/parseSingleLine.js","webpack:///./src/util/size.js","webpack:///./src/util/squeeze.js","webpack:///./src/util/startMultiLineComment.js","webpack:///./src/index.js"],"names":["trim","str","arr","log","defaults","newArr","Array","isArray","concat","trimmedStr","forEach","regEx","replace","endMultiLineComment","parseMultiLine","parseSingleLine","singleLineComment","startMultiLineComment","size","squeeze","normalize","getStrIndex","cleanLine","line","match","DSS","parsers","parse","bind","detector","alias","callback","detect","name","newName","oldName","_temp","block","file","from","to","options","temp","parts","index","length","substr","output","contents","indexOf","nextParserIndex","markupLength","parserMarker","split","splice","join","newLine","call","push","Object","assign","lines","currentBlock","insideSingleLineBlock","insideMultiLineBlock","lastLine","_parsed","_blocks","parsed","blocks","lineNum","toString","text","_block","console","filter","parseLine","ret","i","pattern","cleanedLine","find","textBlock","innerBlock","indentSize","unindented","map","precedingWhitespace","slice","cleaned","obj","keys","def","dss","reference","pop","parser","state","escaped","description","example"],"mappings":"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B,MAAxB,CAA+B,UAACpD,IAAD,EAAU;AACnDmD,4BAAQvE,GAAR,CAAY,qBAAUoB,IAAV,CAAZ,EAA6B,iBAA7B;AACA,2BAAO,gBAAK,qBAAUA,IAAV,CAAL,CAAP;AACH,iBAHa,EAGXgC,IAHW,CAGN,IAHM,CAAd;AAIAmB,wBAAQvE,GAAR,CAAYkC,KAAZ,EAAmB,OAAnB;AACA;AACA;AACA;;AAEA;AACAA,sBAAMgB,KAAN,CAAY,IAAZ,EAAkB3C,OAAlB,CAA0B,UAACa,IAAD,EAAU;AAChC,wBAAI,MAAKS,MAAL,CAAYT,IAAZ,CAAJ,EAAuB;AACnBmB,+BAAO,MAAKkC,SAAL,CAAelC,IAAf,EAAqB,qBAAUnB,IAAV,CAArB,EAAsCc,KAAtC,EAA6CwB,KAA7C,EAAoDtB,IAApD,EAA0DC,EAA1D,EAA8DC,OAA9D,CAAP;AACH;AACJ,iBAJD;;AAMA;AACA,oBAAI,gBAAKC,IAAL,CAAJ,EAAgB;AACZ2B,2BAAOX,IAAP,CAAYhB,IAAZ;AACH;AACDA,uBAAO,EAAP;AACH,aA5BD;;AA8BA;AACAX,qBAAS,EAAEsC,cAAF,EAAT;AACH;;;;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;kBA/pBqB5C,G;;;;;;;;;;;;;kBCXGH,S;;AAFxB;;;;;;AAEe,SAASA,SAAT,CAAmB0B,QAAnB,EAA6BI,YAA7B,EAA2C;AACtD,QAAMyB,MAAM,EAAZ;AACA,QAAMhB,QAAQb,SAASK,KAAT,CAAe,IAAf,CAAd;;AAEAQ,UAAMnD,OAAN,CAAc,UAACa,IAAD,EAAOuD,CAAP,EAAa;AACvB,YAAMC,UAAU,GAAhB;AACA,YAAMnC,QAAQrB,KAAK0B,OAAL,CAAa8B,OAAb,CAAd;AACA,YAAIC,cAAczD,IAAlB;;AAEA,YAAIqB,SAAS,CAAT,IAAcA,QAAQ,EAA1B,EAA8B;AAC1BoC,0BAAcA,YAAY3B,KAAZ,CAAkB,EAAlB,EAAsBC,MAAtB,CAA8BV,QAAQmC,QAAQlC,MAA9C,EAAuDmC,YAAYnC,MAAnE,EAA2EU,IAA3E,CAAgF,EAAhF,CAAd;AACH;;A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","file":"dss.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 13);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0e2daa0ff6297c50c7a5","export default function trim(str, arr, log) {\n    const defaults = [/^\\s\\s*/, /\\s\\s*$/];\n    const newArr = Array.isArray(arr) ? arr.concat(defaults) : defaults;\n    let trimmedStr;\n    newArr.forEach((regEx) => {\n        trimmedStr = str.replace(regEx, '');\n    });\n    return trimmedStr;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/util/trim.js","import endMultiLineComment from './endMultiLineComment';\nimport parseMultiLine from './parseMultiLine';\nimport parseSingleLine from './parseSingleLine';\nimport singleLineComment from './singleLineComment';\nimport startMultiLineComment from './startMultiLineComment';\nimport trim from './trim';\nimport size from './size';\nimport squeeze from './squeeze';\nimport normalize from './normalize';\nimport getStrIndex from './getStrIndex';\nimport cleanLine from './cleanLine';\n\nexport default {\n    endMultiLineComment,\n    parseMultiLine,\n    parseSingleLine,\n    singleLineComment,\n    startMultiLineComment,\n    trim,\n    size,\n    squeeze,\n    normalize,\n    getStrIndex,\n    cleanLine\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/util/index.js","/*\n * Check for single-line comment\n *\n * @param (String) line to parse/check\n * @return (Boolean) result of check\n */\nexport default function singleLineComment(line) {\n    return !!line.match(/^\\s*\\/\\//);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/util/singleLineComment.js","import {\n    singleLineComment,\n    startMultiLineComment,\n    endMultiLineComment,\n    parseSingleLine,\n    parseMultiLine,\n    trim,\n    size,\n    normalize,\n    getStrIndex,\n    cleanLine\n} from './util';\n\nexport default class DSS {\n    constructor() {\n        this.parsers = {};\n        this.parse = this.parse.bind(this);\n        this.detector = this.detector.bind(this);\n        this.alias = this.alias.bind(this);\n    }\n\n    detect() {\n        return true;\n    }\n\n    detector(callback) {\n        this.detect = callback;\n    }\n\n    parser(name, callback) {\n        this.parsers[name] = callback;\n    }\n\n    alias(newName, oldName) {\n        this.parsers[newName] = this.parsers[oldName];\n    }\n\n    parseLine(_temp, line, block, file, from, to, options) {\n        let temp = _temp;\n        const parts = line.replace(/.*@/, '');\n        const index = getStrIndex(parts, ' ') || getStrIndex(parts, '\\n') || getStrIndex(parts, '\\r') || parts.length;\n        const name = trim(parts.substr(0, index));\n        const output = {\n            options,\n            file,\n            name,\n            line: {\n                contents: trim(parts.substr(index), [], 'trimming from output'),\n                from: block.indexOf(line),\n                to: block.indexOf(line)\n            },\n            block: {\n                contents: block,\n                from,\n                to\n            }\n        };\n\n        // find the next instance of a parser (if there is one based on the @ symbol)\n        // in order to isolate the current multi-line parser\n        const nextParserIndex = block.indexOf('* @', output.line.from + 1);\n        const markupLength = (nextParserIndex > -1) ? nextParserIndex - output.line.from : block.length;\n        const parserMarker = `@${name}`;\n        const contents = block.split('').splice(output.line.from, markupLength).join('').replace(parserMarker, '');\n\n        // Redefine output contents to support multiline contents\n        output.line.contents = cleanLine(contents, parserMarker);\n\n        const newLine = {};\n        newLine[name] = (this.parsers[name]) ? this.parsers[name].call(output, output) : '';\n\n        if (temp[name]) {\n            if (!Array.isArray(temp[name])) {\n                temp[name] = [temp[name]];\n            }\n            if (!Array.isArray(line[name])) {\n                temp[name].push(line[name]);\n            } else {\n                temp[name].push(line[name][0]);\n            }\n        } else {\n            temp = Object.assign({}, temp, line);\n        }\n        return temp;\n    }\n\n    parse(lines, options = {}, callback) {\n        // Options\n        // options.preserveWhitespace = !!(options.preserveWhitespace);\n\n        // Setup\n        let currentBlock = '';\n        let insideSingleLineBlock = false;\n        let insideMultiLineBlock = false;\n        let lastLine;\n        // const start = '{start}';\n        // const end = '{/end}';\n        let _parsed = false;\n        const _blocks = [];\n        let parsed = '';\n        const blocks = [];\n        let temp = {};\n        let lineNum = 0;\n        let from = 0;\n        let to = 0;\n\n        lines.toString().split(/\\n/).forEach((line) => {\n            // Increment line number and ensure line is treated as a string\n            lineNum++;\n\n            // Store starting line number\n            if (singleLineComment(line) || startMultiLineComment(line)) {\n                from = lineNum;\n            }\n\n            // Parse Single line comment\n            if (singleLineComment(line)) {\n                parsed = parseSingleLine(line);\n                if (insideSingleLineBlock) {\n                    currentBlock += `\\n${parsed}`;\n                } else {\n                    currentBlock = parsed;\n                    insideSingleLineBlock = true;\n                }\n            }\n\n            // Parse multi-line comments\n            if (startMultiLineComment(line) || insideMultiLineBlock) {\n                parsed = parseMultiLine(line);\n                if (insideMultiLineBlock) {\n                    currentBlock += `\\n${parsed}`;\n                } else {\n                    currentBlock += parsed;\n                    insideMultiLineBlock = true;\n                }\n            }\n\n            // End a multi-line block\n            if (endMultiLineComment(line)) {\n                insideMultiLineBlock = false;\n            }\n\n            // Store current block if done\n            if (!singleLineComment(line) && !insideMultiLineBlock) {\n                if (currentBlock) {\n                    _blocks.push({ text: normalize(currentBlock), from, to: lineNum });\n                }\n                insideSingleLineBlock = false;\n                currentBlock = '';\n                lastLine = '';\n            }\n        });\n\n        // Done first pass\n        _parsed = true;\n\n        // Create new blocks with custom parsing\n        _blocks.forEach((_block) => {\n            // Store line numbers\n            from = _block.from;\n            to = _block.to;\n\n            // Remove extra whitespace\n            console.log(_block, '_block');\n            const block = _block.text.split('\\n').filter((line) => {\n                console.log(normalize(line), 'normalized line');\n                return trim(normalize(line))\n            }).join('\\n');\n            console.log(block, 'block');\n            // const block = _block.text.split('\\n').filter(line => (\n            //     trim(normalize(line))\n            // )).join('\\n');\n\n            // Split block into lines\n            block.split('\\n').forEach((line) => {\n                if (this.detect(line)) {\n                    temp = this.parseLine(temp, normalize(line), block, lines, from, to, options);\n                }\n            });\n\n            // Push to blocks if object isn't empty\n            if (size(temp)) {\n                blocks.push(temp);\n            }\n            temp = {};\n        });\n\n        // Execute callback with filename and blocks\n        callback({ blocks });\n    }\n}\n\n// // DSS Object\n// var dss = ( function () {\n//\n//   // Store reference\n//   var _dss = function () {};\n//\n//   // Store parsers\n//   _dss.parsers = {};\n//\n//   // Default detect function\n//   _dss.detect = function () {\n//     return true;\n//   };\n//\n//   /*\n//    * Modify detector method\n//    *\n//    * @param (Function) The callback to be used to detect variables\n//    */\n//   _dss.detector = function ( callback ) {\n//     _dss.detect = callback;\n//   };\n//\n//   /*\n//    * Add a parser for a specific variable\n//    *\n//    * @param (String) The name of the variable\n//    * @param (Function) The callback to be executed at parse time\n//    */\n//   _dss.parser = function ( name, callback ) {\n//     _dss.parsers[ name ] = callback;\n//   };\n//\n//   /*\n//    * Add an alias for a parser\n//    *\n//    * @param (String) The name of the new variable\n//    * @param (String) The name of the existing parser to use\n//    */\n//   _dss.alias = function ( newName, oldName ) {\n//     _dss.parsers[ newName ] = _dss.parsers[ oldName ];\n//   };\n//\n//   /*\n//    * Trim whitespace from string\n//    *\n//    * @param (String) The string to be trimmed\n//    * @return (String) The trimmed string\n//    */\n//   _dss.trim = function ( str, arr ) {\n//     var defaults = [ /^\\s\\s*/, /\\s\\s*$/ ];\n//     arr = ( _dss.isArray( arr ) ) ? arr.concat( defaults ) : defaults;\n//     arr.forEach( function( regEx ) {\n//       str = str.replace( regEx, '' );\n//     } );\n//     return str;\n//   };\n//\n//   /*\n//    * Check if object is an array\n//    *\n//    * @param (Object) The object to check\n//    * @return (Boolean) The result of the test\n//    */\n//   _dss.isArray = function ( obj ) {\n//     return toString.call( obj ) == '[object Array]';\n//   };\n//\n//   /*\n//    * Check the size of an object\n//    *\n//    * @param (Object) The object to check\n//    * @return (Boolean) The result of the test\n//    */\n//   _dss.size = function ( obj ) {\n//     var size = 0;\n//     for ( var key in obj ) {\n//       if ( Object.prototype.hasOwnProperty.call( obj, key ) )\n//         size++;\n//     }\n//     return size;\n//   };\n//\n//   /*\n//    * Iterate over an object\n//    *\n//    * @param (Object) The object to iterate over\n//    * @param (Function) Callback function to use when iterating\n//    * @param (Object) Optional context to pass to iterator\n//    */\n//   _dss.each = function ( obj, iterator, context ) {\n//     if ( obj == null ) {\n//       return;\n//     }\n//     if ( obj.length === +obj.length ) {\n//       for ( var i = 0, l = obj.length; i < l; i++ ) {\n//         if ( iterator.call( context, obj[ i ], i, obj ) === {} ) {\n//           return;\n//         }\n//       }\n//     } else {\n//       for ( var key in obj ) {\n//         if ( _.has( obj, key ) ) {\n//           if ( iterator.call( context, obj[ key ], key, obj ) === {} ) {\n//             return;\n//           }\n//         }\n//       }\n//     }\n//   };\n//\n//   /*\n//    * Extend an object\n//    *\n//    * @param (Object) The object to extend\n//    */\n//   _dss.extend = function ( obj ) {\n//     _dss.each( Array.prototype.slice.call( arguments, 1 ), function ( source ) {\n//       if ( source ) {\n//         for ( var prop in source ) {\n//           obj[ prop ] = source[ prop ];\n//         }\n//       }\n//     });\n//     return obj;\n//   };\n//\n//   /*\n//    * Squeeze unnecessary extra characters/string\n//    *\n//    * @param (String) The string to be squeeze\n//    * @param (String) The string to be matched\n//    * @return (String) The modified string\n//    */\n//   _dss.squeeze = function ( str, def ) {\n//     return str.replace( /\\s{2,}/g, def );\n//   };\n//\n//   /*\n//    * Normalizes the comment block to ignore any consistent preceding\n//    * whitespace. Consistent means the same amount of whitespace on every line\n//    * of the comment block. Also strips any whitespace at the start and end of\n//    * the whole block.\n//    *\n//    * @param (String) Text block\n//    * @return (String) A cleaned up text block\n//    */\n//   _dss.normalize = function ( text_block ) {\n//\n//     // Strip out any preceding [whitespace]* that occurs on every line\n//     text_block = text_block.replace( /^(\\s*\\*+)/, '' );\n//\n//     // Strip consistent indenting by measuring first line's whitespace\n//     var indent_size = false;\n//     var unindented = ( function ( lines ) {\n//       return lines.map( function ( line ) {\n//         var preceding_whitespace = line.match( /^\\s*/ )[ 0 ].length;\n//         if ( !indent_size ) {\n//           indent_size = preceding_whitespace;\n//         }\n//         if ( line == '' ) {\n//           return '';\n//         } else if ( indent_size <= preceding_whitespace && indent_size > 0 ) {\n//           return line.slice( indent_size, ( line.length - 1 ) );\n//         } else {\n//           return line;\n//         }\n//       } ).join( \"\\n\" );\n//     } )( text_block.split( \"\\n\" ) );\n//\n//     return _dss.trim( text_block );\n//\n//   };\n//\n//   /*\n//    * Takes a file and extracts comments from it.\n//    *\n//    * @param (Object) options\n//    * @param (Function) callback\n//    */\n//   _dss.parse = function ( lines, options, callback ) {\n//\n//     // Options\n//     options = ( options ) ? options : {};\n//     options.preserve_whitespace = !!( options.preserve_whitespace );\n//\n//     // Setup\n//     var current_block             = '';\n//     var inside_single_line_block  = false;\n//     var inside_multi_line_block   = false;\n//     var last_line                 = '';\n//     var start                     = '{start}';\n//     var end                       = '{/end}';\n//     var _parsed                   = false;\n//     var _blocks                   = [];\n//     var parsed                    = '';\n//     var blocks                    = [];\n//     var temp                      = {};\n//     var lineNum                   = 0;\n//     var from                      = 0;\n//     var to                        = 0;\n//\n//     lines = lines + '';\n//     lines.split( /\\n/ ).forEach( function ( line ) {\n//\n//       // Iterate line number and ensure line is treaty as a string\n//       lineNum = lineNum + 1;\n//       line = line + '';\n//\n//       // Store starting line number\n//       if ( single_line_comment( line ) || start_multi_line_comment( line ) ) {\n//         from = lineNum;\n//       }\n//\n//       // Parse Single line comment\n//       if ( single_line_comment( line ) ) {\n//         parsed = parse_single_line( line );\n//         if ( inside_single_line_block ) {\n//           current_block += '\\n' + parsed;\n//         } else {\n//           current_block = parsed;\n//           inside_single_line_block = true;\n//         }\n//       }\n//\n//       // Parse multi-line comments\n//       if ( start_multi_line_comment( line ) || inside_multi_line_block ) {\n//         parsed = parse_multi_line( line );\n//         if ( inside_multi_line_block ) {\n//           current_block += '\\n' + parsed;\n//         } else {\n//           current_block += parsed;\n//           inside_multi_line_block = true;\n//         }\n//       }\n//\n//       // End a multi-line block\n//       if ( end_multi_line_comment( line ) ) {\n//         inside_multi_line_block = false;\n//       }\n//\n//       // Store current block if done\n//       if ( !single_line_comment( line ) && !inside_multi_line_block ) {\n//         if ( current_block ) {\n//           _blocks.push( { text: _dss.normalize( current_block ), from: from, to: lineNum } );\n//         }\n//         inside_single_line_block = false;\n//         current_block = '';\n//         last_line = '';\n//       }\n//\n//     });\n//\n//     // Done first pass\n//     _parsed = true;\n//\n//     // Create new blocks with custom parsing\n//     _blocks.forEach( function ( block ) {\n//\n//       // Store line numbers\n//       var from = block.from;\n//       var to = block.to;\n//\n//       // Remove extra whitespace\n//       block = block.text.split( '\\n' ).filter( function ( line ) {\n//         return ( _dss.trim( _dss.normalize( line ) ) );\n//       } ).join( '\\n' );\n//\n//       // Split block into lines\n//       block.split( '\\n' ).forEach( function ( line ) {\n//         if ( _dss.detect( line ) ) {\n//           temp = parser( temp, _dss.normalize( line ), block, lines, from, to, options );\n//         }\n//       });\n//\n//       // Push to blocks if object isn't empty\n//       if( _dss.size( temp ) ) {\n//         blocks.push( temp );\n//       }\n//       temp = {};\n//\n//     });\n//\n//     // Execute callback with filename and blocks\n//     callback( { blocks: blocks } );\n//\n//   };\n//\n//   /*\n//    * Parses line\n//    *\n//    * @param (Num) the line number\n//    * @param (Num) number of lines\n//    * @param (String) line to parse/check\n//    * @return (Boolean) result of parsing\n//    */\n//   function parser ( temp, line, block, file, from, to, options ) {\n//\n//     var parts           = line.replace( /.*@/, '' );\n//     var index           = indexer( parts, ' ' ) || indexer( parts, '\\n' ) || indexer( parts, '\\r' ) || parts.length;\n//     var name            = _dss.trim( parts.substr( 0, index ) );\n//     var output          = {\n//       options: options,\n//       file: file,\n//       name: name,\n//       line: {\n//         contents: _dss.trim( parts.substr( index ) ),\n//         from: block.indexOf( line ),\n//         to: block.indexOf( line )\n//       },\n//       block: {\n//         contents: block,\n//         from: from,\n//         to: to\n//       }\n//     };\n//\n//     // find the next instance of a parser (if there is one based on the @ symbol)\n//     // in order to isolate the current multi-line parser\n//     var nextParserIndex = block.indexOf( '* @', output.line.from + 1 );\n//     var markupLength = ( nextParserIndex > -1 ) ? nextParserIndex - output.line.from : block.length;\n//     var contents = block.split( '' ).splice( output.line.from , markupLength ).join( '' );\n//     var parserMarker = '@' + name;\n//     contents = contents.replace( parserMarker, '' );\n//\n//     // Redefine output contents to support multiline contents\n//     output.line.contents = ( function( contents ) {\n//       var ret = [];\n//       var lines = contents.split( '\\n' );\n//\n//       lines.forEach( function( line, i ) {\n//\n//         var pattern = '*';\n//         var index = line.indexOf( pattern );\n//\n//         if ( index >= 0 && index < 10 ) {\n//           line = line.split( '' ).splice( ( index + pattern.length ), line.length ).join( '' );\n//         }\n//\n//         // Trim whitespace from the the first line in multiline contents\n//         if ( i === 0 ) {\n//           line = _dss.trim( line );\n//         }\n//\n//         if ( line && line.indexOf( parserMarker ) == -1 ) {\n//           ret.push( line );\n//         }\n//\n//       });\n//\n//       return ret.join( '\\n' );\n//\n//     })( contents );\n//\n//     line = {};\n//     line[ name ] = ( _dss.parsers[ name ] ) ? _dss.parsers[ name ].call( output ) : '';\n//\n//     if ( temp[ name ] ) {\n//       if ( !_dss.isArray( temp[ name ] ) ) {\n//         temp[name] = [ temp[ name ] ];\n//       }\n//       if ( !_dss.isArray( line[ name ] ) ) {\n//         temp[ name ].push( line[ name ] );\n//       } else {\n//         temp[ name ].push( line[ name ][ 0 ] );\n//       }\n//     } else {\n//       temp = _dss.extend( temp, line );\n//     }\n//     return temp;\n//   };\n//\n//\n//   /*\n//    * Comment block\n//    */\n//   function block () {\n//     this._raw = ( comment_text ) ? comment_text : '';\n//     this._filename = filename;\n//   };\n//\n//   /*\n//    * Check for single-line comment\n//    *\n//    * @param (String) line to parse/check\n//    * @return (Boolean) result of check\n//    */\n//   function single_line_comment ( line ) {\n//     return !!line.match( /^\\s*\\/\\// );\n//   };\n//\n//   /*\n//    * Checks for start of a multi-line comment\n//    *\n//    * @param (String) line to parse/check\n//    * @return (Boolean) result of check\n//    */\n//   function start_multi_line_comment ( line ) {\n//     return !!line.match( /^\\s*\\/\\*/ );\n//   };\n//\n//   /*\n//    * Check for end of a multi-line comment\n//    *\n//    * @parse (String) line to parse/check\n//    * @return (Boolean) result of check\n//    */\n//   function end_multi_line_comment ( line ) {\n//     if( single_line_comment( line ) ) {\n//       return false;\n//     }\n//     return !!line.match( /.*\\*\\// );\n//   };\n//\n//   /*\n//    * Removes comment identifiers for single-line comments.\n//    *\n//    * @param (String) line to parse/check\n//    * @return (Boolean) result of check\n//    */\n//   function parse_single_line ( line ) {\n//     return line.replace( /\\s*\\/\\//, '' );\n//   };\n//\n//   /*\n//    * Remove comment identifiers for multi-line comments.\n//    *\n//    * @param (String) line to parse/check\n//    * @return (Boolean) result of check\n//    */\n//   function parse_multi_line ( line ) {\n//     var cleaned = line.replace( /\\s*\\/\\*/, '' );\n//     return cleaned.replace( /\\*\\//, '' );\n//   };\n//\n//   // Return function\n//   return _dss;\n//\n// })();\n//\n// // Describe default detection pattern\n// dss.detector( function( line ) {\n//   if ( typeof line !== 'string' ) {\n//     return false;\n//   }\n//   var reference = line.split( \"\\n\\n\" ).pop();\n//   return !!reference.match( /.*@/ );\n// });\n//\n// // Describe default parsing of a name\n// dss.parser( 'name', function () {\n//   return this.line.contents;\n// });\n//\n// // Describe default parsing of a description\n// dss.parser( 'description', function () {\n//   return this.line.contents;\n// });\n//\n// // Describe default parsing of a state\n// dss.parser( 'state', function () {\n//   var state = this.line.contents.split( ' - ' );\n//   return [{\n//     name: ( state[ 0 ] ) ? dss.trim( state[ 0 ] ) : '',\n//     escaped: ( state[ 0 ] ) ? dss.trim( state[ 0 ].replace( '.', ' ' ).replace( ':', ' pseudo-class-' ) ) : '',\n//     description: ( state[ 1 ] ) ? dss.trim( state[ 1 ] ) : ''\n//   }];\n// });\n//\n// // Describe default parsing of a piece markup\n// dss.parser( 'markup', function () {\n//   return [{\n//     example: this.line.contents,\n//     escaped: this.line.contents.replace( /</g, '&lt;' ).replace( />/g, '&gt;' )\n//   }];\n// });\n//\n// // Module exports\n// if( typeof exports !== 'undefined' ) {\n//   if ( typeof module !== 'undefined' && module.exports ) {\n//     exports = module.exports = dss;\n//   }\n//   exports.dss = dss;\n// } else {\n//   root[ 'dss' ] = dss;\n// }\n//\n// // AMD definition\n// if ( typeof define === 'function' && define.amd ) {\n//   define( function ( require ) {\n//     return dss;\n//   });\n// }\n\n\n\n// WEBPACK FOOTER //\n// ./src/dss.js","import trim from './trim';\n\nexport default function cleanLine(contents, parserMarker) {\n    const ret = [];\n    const lines = contents.split('\\n');\n\n    lines.forEach((line, i) => {\n        const pattern = '*';\n        const index = line.indexOf(pattern);\n        let cleanedLine = line;\n\n        if (index >= 0 && index < 10) {\n            cleanedLine = cleanedLine.split('').splice((index + pattern.length), cleanedLine.length).join('');\n        }\n\n        // Trim whitespace from the the first line in multiline contents\n        if (i === 0) {\n            cleanedLine = trim(cleanedLine);\n        }\n\n        if (cleanedLine && cleanedLine.indexOf(parserMarker) === -1) {\n            ret.push(cleanedLine);\n        }\n    });\n\n    return ret.join('\\n');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/util/cleanLine.js","import singleLineComment from './singleLineComment';\n\n/*\n * Check for end of a multi-line comment\n *\n * @parse (String) line to parse/check\n * @return (Boolean) result of check\n */\nexport default function endMultiLineComment(line) {\n    if (singleLineComment(line)) {\n        return false;\n    }\n    return !!line.match(/.*\\*\\//);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/util/endMultiLineComment.js","/*\n * Get the index of string inside of another\n */\nexport default function getStrIndex(str, find) {\n    return (str.indexOf(find) > 0) ? str.indexOf(find) : false;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/util/getStrIndex.js","import trim from './trim';\n\n/*\n* Normalizes the comment block to ignore any consistent preceding\n* whitespace. Consistent means the same amount of whitespace on every line\n* of the comment block. Also strips any whitespace at the start and end of\n* the whole block.\n*\n* @param (String) Text block\n* @return (String) A cleaned up text block\n*/\n\nexport default function normalize(textBlock) {\n    // Strip out any preceding [whitespace]* that occurs on every line\n    const innerBlock = textBlock.replace(/^(\\s+\\*+)/, '');\n\n    // Strip consistent indenting by measuring first line's whitespace\n    let indentSize;\n    const unindented = lines => (\n        lines.split('\\n').map((line) => {\n            const precedingWhitespace = line.match(/^\\s*/)[0].length;\n            if (!indentSize) indentSize = precedingWhitespace;\n            if (line === '') {\n                return '';\n            } else if (indentSize <= precedingWhitespace && indentSize > 0) {\n                return line.slice(indentSize, line.length);\n            }\n            return line;\n        }).join('\\n')\n    );\n\n    return trim(unindented(innerBlock));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/util/normalize.js","/*\n * Remove comment identifiers for multi-line comments.\n *\n * @param (String) line to parse/check\n * @return (Boolean) result of check\n */\nexport default function parseMultiLine(line) {\n    const cleaned = line.replace(/\\s*\\/\\*/, '').replace(/\\*\\//, '');\n    return cleaned;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/util/parseMultiLine.js","/*\n * Removes comment identifiers for single-line comments.\n *\n * @param (String) line to parse/check\n * @return (Boolean) result of check\n */\nexport default function parseSingleLine(line) {\n    return line.replace(/\\s*\\/\\//, '');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/util/parseSingleLine.js","export default function size(obj) {\n    return Object.keys(obj).length;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/util/size.js","export default function squeeze(str, def) {\n    return str.replace(/\\s{2,}/g, def);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/util/squeeze.js","/*\n * Checks for start of a multi-line comment\n *\n * @param (String) line to parse/check\n * @return (Boolean) result of check\n */\nexport default function startMultiLineComment(line) {\n    return !!line.match(/^\\s*\\/\\*/);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/util/startMultiLineComment.js","import DSS from './dss';\nimport { trim } from './util';\n\nconst dss = new DSS();\n\n// Describe default detection pattern\ndss.detector((line) => {\n    if (typeof line !== 'string') {\n        return false;\n    }\n    const reference = line.split('\\n\\n').pop();\n    return !!reference.match(/.*@/);\n});\n\n// Describe default parsing of a name\ndss.parser('name', ({ line }) => line.contents);\n\n// Describe default parsing of a description\ndss.parser('description', ({ line }) => line.contents);\n\n// Describe default parsing of a state\ndss.parser('state', ({ line }) => {\n    const state = line.contents.split(' - ');\n    return [{\n        name: (state[0]) ? trim(state[0]) : '',\n        escaped: (state[0]) ? trim(state[0].replace('.', ' ').replace(':', ' pseudo-class-')) : '',\n        description: (state[1]) ? trim(state[1]) : ''\n    }];\n});\n\n// Describe default parsing of a piece markup\ndss.parser('markup', ({ line }) => (\n    [{\n        example: line.contents,\n        escaped: line.contents.replace(/</g, '&lt;').replace(/>/g, '&gt;')\n    }]\n));\n\nexport default dss;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}